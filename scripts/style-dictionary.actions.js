const StyleDictionary = require("style-dictionary");
const baseConfig = require("./style-dictionary.config.json");
const _ = require("lodash");

function objectToRgba(colorObj) {
  // Extract color values
  const r = Math.round(colorObj.r * 255);
  const g = Math.round(colorObj.g * 255);
  const b = Math.round(colorObj.b * 255);
  const a = colorObj.a;

  // Format the RGBA string
  const rgbaColor = `rgba(${r}, ${g}, ${b}, ${a})`;

  return rgbaColor;
}

/**
 * Parses the JSON file defined in the `style-dictionary.config.json`
 * JSON is downloaded from this Community Plugin: https://www.figma.com/community/plugin/1253571037276959291
 */
function toStyleDictionaryFormat(inputJson, filePath) {
  const styleDictionary = {};
  const collection = _.kebabCase(inputJson.name);
  const modes = inputJson.modes;
  const variables = inputJson.variables;

  for (const mode in modes) {
    variables.map((variable) => {
      const modeName = _.kebabCase(modes[mode]);
      const newVarName = _.kebabCase(
        `${collection}-${modeName}-${variable.name}`
      );

      styleDictionary[newVarName] = {
        ...variable,
        name: newVarName,
        collection: collection,
        file: filePath,
        mode: modeName,
        value: variable.resolvedValuesByMode[mode].resolvedValue,
        alias: _.kebabCase(variable.resolvedValuesByMode[mode].aliasName),
      };
    });
  }

  return styleDictionary;
}

StyleDictionary.registerParser({
  pattern: /\.json$/,
  parse: ({ filePath, contents }) => {
    return toStyleDictionaryFormat(JSON.parse(contents), filePath);
  },
});

/**
 * StyleDictionary: Transforms
 * ----------------------------------------
 */

StyleDictionary.registerTransform({
  name: "name-transform",
  type: "name",
  transformer: (token) => {
    let newTokenName = token.name;
    return newTokenName;
  },
});

StyleDictionary.registerTransform({
  name: "value-transform",
  type: "value",
  transformer: (token) => {
    let newTokenValue = token.value;
    if (token.type === "COLOR") {
      newTokenValue = objectToRgba(token.value);
    }

    if (token.collection === "semantic")
      newTokenValue = `var(--${token.alias})`;

    return newTokenValue;
  },
});

StyleDictionary.registerTransformGroup({
  name: "custom/group",
  transforms: ["name-transform", "value-transform"],
});

/**
 * StyleDictionary: Formats
 * ----------------------------------------
 */
// StyleDictionary.registerFormat({
//   name: "custom/css",
//   formatter: function ({ dictionary, file, options }) {
//     let collections = [];

//     dictionary.allTokens.map((token) => {
//       const collectionName = _.camelCase(token.collection);
//       if (!collections.includes(token.collection)) {
//         collections.push(token.collection);
//       }
//     });

//     let output = collections
//       .map((c) => {
//         return `/* ${_.camelCase(c)} */
//       ${dictionary.allTokens
//         .filter((tkn) => {
//           return tkn.collection === c;
//         })
//         .map((token) => {
//           return `--${token.name} : ${token.value};`;
//         })
//         .join("\n")}
//     \n`;
//       })
//       .join("");

//     return `/* Generated by friendly robots. */\n\n:root {\n${output}\n}`;
//   },
// });

StyleDictionary.registerFormat({
  name: "custom/css/theme",
  formatter: function ({ dictionary }) {
    const lightColors = `@media (prefers-color-scheme: light) {\n :root {
      ${dictionary.allTokens
        .map((token) => {
          if (token.mode === "light") {
            return `--${token.name
              .replace("foundation-", "")
              .replace("light-", "")}:${token.value};`;
          }
        })
        .join("\n")}
    }}`;

    const darkColors = `@media (prefers-color-scheme: dark) {\n :root {
      ${dictionary.allTokens
        .map((token) => {
          if (token.mode === "dark") {
            return `--${token.name
              .replace("foundation-", "")
              .replace("dark-", "")}:${token.value};`;
          }
        })
        .join("\n")}
    }}`;

    const remaining = `:root {
      ${dictionary.allTokens
        .map((token) => {
          if (token.mode === "mode-1") {
            return `--${token.name
              .replace("mode-1-", "")
              .replace("semantic-", "")}:${token.value};`;
          }
        })
        .join("\n")}
    }`;

    return `${lightColors}${darkColors}${remaining}`;
  },
});

StyleDictionary.registerFormat({
  name: "custom/js",
  formatter: function ({ dictionary, file, options }) {
    let collections = [];

    dictionary.allTokens.map((token) => {
      const collectionName = _.camelCase(token.collection);
      if (!collections.includes(token.collection)) {
        collections.push(token.collection);
      }
    });

    let output = collections
      .map((c) => {
        return `window.${_.camelCase(c)} = {
      ${dictionary.allTokens
        .filter((tkn) => {
          return tkn.collection === c;
        })
        .map((token) => {
          let value = token.value;
          let tname = token.name
            .replace("foundation-", "")
            .replace("semantic-", "")
            .replace("mode-1-", "");

          if (token.collection === "keyframes") {
            value = unescape(token.value);
          }

          return `"${tname}" : "${value}"`;
        })
        .join(",")}
    }\n`;
      })
      .join("");

    return `${output}`;
  },
});

StyleDictionary.registerFormat({
  name: "custom/tailwind",
  formatter: function ({ dictionary, file, options }) {
    let theme = {};

    dictionary.allTokens.forEach((token) => {
      if (token.collection !== "semantic") {
        return; // Skip non-semantic tokens
      }

      const collectionName = _.camelCase(token.collection);
      const tokenName = token.name
        .replace("foundation-", "")
        .replace("semantic-", "")
        .replace("mode-1-", "");

      if (!theme[collectionName]) {
        theme[collectionName] = {};
      }

      theme[collectionName][tokenName] = token.value;
    });

    return `export default {
            content: ["./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}"],
            theme: {
              extend: ${JSON.stringify(theme, null, 2)},
            },
            plugins: [],
          };`;
  },
});

const StyleDictionaryExtended = StyleDictionary.extend(baseConfig);
StyleDictionaryExtended.buildAllPlatforms();
